{"mappings":"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","sources":["./src/com/Vector.ts","./src/com/Constants.ts","./src/com/Entity.ts","./src/com/Projectile.ts","./src/com/Enemies/Enemy.ts","./src/com/Enemies/Circle.ts","./src/com/Enemies/Square.ts","./src/com/PlayerInput.ts","./src/com/Player.ts","./src/com/Game.ts","./src/draw/Drawer.ts","./src/Application.ts","./src/index.ts"],"sourcesContent":["\nexport interface IVector {\n    x?: number;\n    y?: number;\n}\n\nexport class Vector implements IVector{\n    x: number;\n    y: number;\n\n    constructor(v: IVector) {\n        this.x = v.x ?? 0;\n        this.y = v.y ?? 0;\n    }\n\n    static getRandomVector(max?: IVector): Vector {\n        return new Vector({\n            x: Math.random()* (max?.x || 1),\n            y: Math.random()* (max?.y || 1)\n        });\n    }\n\n    add(v: Vector): Vector {\n        this.x += v.x;\n        this.y += v.y;\n        return this;\n    }\n\n    minus(v: Vector): Vector {\n        this.x -= v.x;\n        this.y -= v.y;\n        return this;\n    }\n\n    multByScalar(scalar: number): Vector {\n        this.x *= scalar;\n        this.y *= scalar;\n        return this;\n    }\n\n    lenght(): number {\n        return Math.sqrt( this.x**2 + this.y**2 );\n    }\n\n    normalize(): Vector {\n        const tmpL = this.lenght();\n        this.x /= tmpL;\n        this.y /= tmpL;\n        return this;\n    }\n\n    distanceTo(other: Vector): number {\n        return Math.sqrt( (this.x-other.x)**2 + (this.y-other.y)**2 );\n    }\n \n}","import {Vector} from \"./Vector\";\n\nexport const GAME_LIMITS: Vector = new Vector({x: 800, y: 400});\nexport const PLAYER_SIZE: number = 20;\nexport const PLAYER_HALF_SIZE: number = PLAYER_SIZE / 2.;\nexport const PLAYER_SPEED: number = 2;\nexport const ENEMY_SIZE: number = 15;\nexport const ENEMY_HALF_SIZE: number = ENEMY_SIZE / 2.;\nexport const ENEMY_MAX_LINEAR_SPEED: number = 1.5;\nexport const FIRE_INPUT_MIN_LENGTH: number = 0.20;\nexport const PROJECTILE_SIZE: number = 4;\nexport const PROJECTILE_SPEED: number = 4;\nexport const PROJECTILE_LIFETIME_MS: number = 1500;\nexport const MAX_SPAWN_TIME: number = 4000;\nexport const PLAYER_INVINCIBILITY_TIMEFRAME = 1000;\nexport const SPECIAL_INPUTS_LATENCY = 1000;\nexport const PLAYER_LIFES = 3;\nexport const LIFE_DISPLAY_SIZE = 15;","import { PlayerInputs } from \"./PlayerInput\";\nimport {Vector, IVector} from \"./Vector\";\n\nexport abstract class Entity {\n    position: Vector;\n    speed: Vector;\n    size: number;\n    alive: boolean = true;\n\n    constructor(pos: IVector, speed: IVector, size?: number) {\n        this.position = new Vector(pos);\n        this.speed = new Vector(speed);\n        this.size = size ?? 0;\n    }\n\n    abstract move(input?: PlayerInputs, target?: Entity): void;\n    \n    intersect(other: Entity): boolean {\n        if (!this.alive || !other.alive) {\n            return false;\n        }\n        const threshold = this.size/2 + other.size/2;\n\n        const distance = (new Vector(this.position)).minus(other.position).lenght();\n        return distance < threshold;\n    }\n\n    die(): void {\n        this.alive = false;\n    }\n\n\n}","import { PROJECTILE_LIFETIME_MS, PROJECTILE_SIZE, PROJECTILE_SPEED } from \"./Constants\";\nimport { Entity } from \"./Entity\";\nimport { IVector } from \"./Vector\";\n\nexport default class Projectile extends Entity {\n    deathTimestamp: number;\n\n    constructor(pos: IVector, speed: IVector, spawnTimestamp: number) {\n        super(pos, speed, PROJECTILE_SIZE);\n\n        this.speed.normalize().multByScalar(PROJECTILE_SPEED);\n\n        this.deathTimestamp = spawnTimestamp+PROJECTILE_LIFETIME_MS;\n    }\n\n    move(): void {\n        this.position.add(this.speed);\n    }\n\n    isAlive(timestamp: number): boolean {\n        return this.alive && this.deathTimestamp > timestamp;\n    }\n\n}","import { ENEMY_HALF_SIZE, ENEMY_SIZE, GAME_LIMITS } from \"../Constants\";\nimport { Entity } from \"../Entity\";\nimport { PlayerInputs } from \"../PlayerInput\";\nimport Projectile from \"../Projectile\";\nimport { IVector, Vector } from \"../Vector\";\n\nexport default abstract class Enemy extends Entity {\n    lives:number = 3;\n    fire_delay: number = 2500;\n    last_fire_timestamp: number = 0;\n\n    constructor(pos: IVector, speed: IVector) {\n        super(pos, speed, ENEMY_SIZE);\n    }\n\n    move(input?: PlayerInputs, target?: Entity): void {\n        const tmpPos = new Vector(this.position);\n        tmpPos.add(this.speed);\n\n        if (tmpPos.x-ENEMY_HALF_SIZE <= 0 || tmpPos.x+ENEMY_HALF_SIZE >= GAME_LIMITS.x) {\n            this.speed.x *= -1;\n        }\n        if (tmpPos.y-ENEMY_HALF_SIZE <= 0 || tmpPos.y+ENEMY_HALF_SIZE >= GAME_LIMITS.y) {\n            this.speed.y *= -1;\n        }\n        this.position.add(this.speed);\n    }\n\n    decreaseLife(val: number = 1) {\n        this.lives -= val;\n        if (this.lives <= 0) {\n            this.die();\n        }\n    }\n\n    fire(targetPos: Vector, timestamp: number): Array<Projectile> {\n        // delay first shot - too hard to dodge !\n        if (this.last_fire_timestamp === 0) {\n            this.last_fire_timestamp = timestamp;\n        }\n        else if (timestamp - this.last_fire_timestamp > this.fire_delay) {\n            this.last_fire_timestamp = timestamp;\n            const speed = (new Vector(targetPos)).minus(this.position);\n            return [new Projectile(this.position, speed , timestamp) ];\n        }\n        return [];\n    }\n\n}","import { Entity } from \"../Entity\";\nimport { PlayerInputs } from \"../PlayerInput\";\nimport { Vector } from \"../Vector\";\nimport Enemy from \"./Enemy\";\n\nexport default class Circle extends Enemy {\n    \n    move(input?: PlayerInputs, target?: Entity): void {\n        if (!target) {\n            throw \"Target needed !\";\n        }\n\n        const tmpSpeed = new Vector(target.position);\n        tmpSpeed.minus(this.position);\n        this.speed = tmpSpeed.normalize();\n\n        super.move(input, target);\n    }\n}","// simplest enemy with shots\n\nimport Enemy from \"./Enemy\";\n\nexport default class Square extends Enemy {\n\n}","import { Vector } from \"./Vector\";\n\n// TODO : check axes and buttons order in all browser. Use userAgent for better detection.\n\nexport let usedGamePad: number;\n\nexport interface PlayerInputs {\n    positionInput: Vector;\n    fireInput: Vector;\n    buttons: {\n        'L1': boolean,\n        'R1': boolean,\n        'Pause': boolean\n    }\n};\n\nfunction getLastUsedGamePad(): Gamepad|null {\n    const pads = Array.from(navigator.getGamepads());\n    pads?.sort( (a,b) => {\n        return (a?.timestamp??0) < (b?.timestamp??0) ? 1 : -1;\n    });\n    \n    return pads ? pads[0] : null;\n}\n\nexport function gamePadRumble(force: number, duration: number) {\n    const gamePad = getLastUsedGamePad();\n    if (gamePad) {\n        gamePad.vibrationActuator.playEffect(\"dual-rumble\", {\n            startDelay: 0,\n            duration,\n            weakMagnitude: force,\n            strongMagnitude: force\n        });\n    }\n}\n\nexport function getCurrentInput(): PlayerInputs {\n    const gamePad = getLastUsedGamePad();\n\n    // L1 = 4\n    // R1 = 5\n    // options/start = 9\n    const buttons = {\n        'L1': gamePad?.buttons[4].pressed ?? false,\n        'R1': gamePad?.buttons[5].pressed ?? false,\n        'Pause': gamePad?.buttons[9].pressed ?? false\n    };\n\n    const positionInput = new Vector({\n        x: gamePad?.axes[0] ?? 0,\n        y: gamePad?.axes[1] ?? 0\n    });\n    const fireInput = new Vector({\n        x: gamePad?.axes[2] ?? 0,\n        y: gamePad?.axes[3] ?? 0\n    });\n    return {\n        positionInput,\n        fireInput,\n        buttons\n    };\n};\n\n","import { FIRE_INPUT_MIN_LENGTH, GAME_LIMITS, PLAYER_HALF_SIZE, PLAYER_INVINCIBILITY_TIMEFRAME, PLAYER_LIFES, PLAYER_SIZE, PLAYER_SPEED } from \"./Constants\";\nimport { Entity } from \"./Entity\";\nimport { gamePadRumble, PlayerInputs } from \"./PlayerInput\";\nimport Projectile from \"./Projectile\";\n\nexport default class Player extends Entity {\n    fire_delay: number = 250;\n    last_fire_timestamp: number = 0;\n    lives: number = PLAYER_LIFES;\n    is_invincible: boolean = false;\n    invincible_until_timestamp: number = 0;\n\n    constructor() {\n        super({x: 250, y: 250}, {}, PLAYER_SIZE);\n    }\n\n    move(input: PlayerInputs): void {\n        this.speed = input.positionInput.multByScalar(PLAYER_SPEED);\n        this.position.add(this.speed);\n\n        if (this.position.x <= PLAYER_HALF_SIZE) {\n            this.position.x = PLAYER_HALF_SIZE;\n        }\n        else if (this.position.x + PLAYER_HALF_SIZE >= GAME_LIMITS.x) {\n            this.position.x = GAME_LIMITS.x - PLAYER_HALF_SIZE;\n        }\n\n        if (this.position.y <= PLAYER_HALF_SIZE) {\n            this.position.y = PLAYER_HALF_SIZE;\n        }\n        else if (this.position.y + PLAYER_HALF_SIZE >= GAME_LIMITS.y) {\n            this.position.y = GAME_LIMITS.y - PLAYER_HALF_SIZE;\n        }\n\n    }\n\n    fire(inputs: PlayerInputs, timestamp: number): Array<Projectile> {\n        if(inputs.fireInput.lenght() > FIRE_INPUT_MIN_LENGTH) {\n            if (timestamp - this.last_fire_timestamp > this.fire_delay) {\n                this.last_fire_timestamp = timestamp;\n                return [new Projectile(this.position, inputs.fireInput, timestamp) ];\n            }\n        }\n        return [];\n    }\n\n    decreaseLife(touchTimestamp: number): void {\n        if (this.is_invincible) return;\n\n        gamePadRumble(.5,500);\n\n        this.lives--;\n\n        if (this.lives <= 0){\n            gamePadRumble(.8,1000);\n            return this.die();\n        }\n\n        this.is_invincible = true;\n        this.invincible_until_timestamp = touchTimestamp + PLAYER_INVINCIBILITY_TIMEFRAME;\n    }\n\n    checkInvincibility(timestamp: number): void {\n        if (this.is_invincible && timestamp >= this.invincible_until_timestamp) {\n            this.is_invincible = false;\n        }\n    }\n\n};","import { ENEMY_MAX_LINEAR_SPEED, FIRE_INPUT_MIN_LENGTH, GAME_LIMITS, MAX_SPAWN_TIME, PLAYER_SIZE, PLAYER_SPEED } from \"./Constants\";\nimport Circle from \"./Enemies/Circle\";\nimport Enemy from \"./Enemies/Enemy\";\nimport Square from \"./Enemies/Square\";\nimport { Entity } from \"./Entity\";\nimport Player from \"./Player\";\nimport { PlayerInputs } from \"./PlayerInput\";\nimport Projectile from \"./Projectile\";\nimport { Vector } from \"./Vector\";\n\nexport default class Game {\n    player: Player;\n    enemies: Array<Enemy> = [];\n\n    nextSpawnTimestamp: number = 0;\n\n    allies_projectiles: Array<Projectile> = [];\n    enemies_projectiles: Array<Projectile> = [];\n\n    particules?: any;\n\n    constructor() {\n        this.player = new Player();\n    }\n\n    reset() {\n        this.player = new Player();\n        this.enemies = [];\n        this.allies_projectiles = [];\n        this.enemies_projectiles = [];\n        this.nextSpawnTimestamp = 0;\n    }\n\n\n    schedule(timestamp: number, inputs: PlayerInputs) {\n        // check player status\n        if (!this.player.alive) {\n            // console.log('terminÃ©');\n            return;\n        }\n\n        this.player.checkInvincibility(timestamp);\n\n        // move player\n        this.player.move(inputs);\n\n        // fire\n        this.allies_projectiles.push(...this.player.fire(inputs, timestamp));\n\n        // move projectiles\n        for (const proj of this.allies_projectiles) {\n            proj.move();\n\n            // allies_proj collisions\n            for (const enemy of this.enemies) {\n                if (enemy.intersect(proj)) {\n                    enemy.decreaseLife();\n                    proj.die();\n                }\n            }\n        }\n        \n        // purge enemies\n        this.enemies = this.enemies.filter(e => e.alive);\n\n        // move enemies\n        for (const enemy of this.enemies) {\n            enemy.move(inputs, this.player);\n\n            // +  enemy body collision w/ player\n            if (enemy.intersect(this.player)) {\n                this.player.decreaseLife(timestamp);\n            }\n            // +  enemy fire\n            this.enemies_projectiles.push(...enemy.fire(this.player.position, timestamp));\n        }\n\n        // enemy_proj move + collisions\n        for (const proj of this.enemies_projectiles) {\n            proj.move();\n\n            if (proj.intersect(this.player)) {\n                this.player.decreaseLife(timestamp);\n                proj.die();\n            }\n        }\n\n        // purge projectiles\n        this.allies_projectiles = this.allies_projectiles.filter(proj => proj.isAlive(timestamp));\n        this.enemies_projectiles = this.enemies_projectiles.filter(proj => proj.isAlive(timestamp));\n\n        // spawn\n        if (timestamp > this.nextSpawnTimestamp || this.enemies.length == 0) {\n            this.enemies.push(this.spawnRandomEnemy());\n\n            this.nextSpawnTimestamp = timestamp + MAX_SPAWN_TIME;\n        }\n        \n    }\n    \n    spawnRandomEnemy() {\n        let rdmPos = Vector.getRandomVector(GAME_LIMITS);\n        while (rdmPos.distanceTo(this.player.position) < PLAYER_SIZE) {\n            rdmPos = Vector.getRandomVector(GAME_LIMITS);\n        }\n\n        // TODO: better spawn randomization\n        if (Math.random() < .5) {\n            return new Square(rdmPos, Vector.getRandomVector().multByScalar(ENEMY_MAX_LINEAR_SPEED) );\n        } else {\n            return new Circle(rdmPos, Vector.getRandomVector().multByScalar(ENEMY_MAX_LINEAR_SPEED) );\n        }\n    }\n\n}","import { ENEMY_HALF_SIZE, ENEMY_SIZE, GAME_LIMITS, LIFE_DISPLAY_SIZE, PLAYER_HALF_SIZE, PLAYER_LIFES, PLAYER_SIZE, PROJECTILE_SIZE } from \"../com/Constants\";\nimport Circle from \"../com/Enemies/Circle\";\nimport Square from \"../com/Enemies/Square\";\nimport Game from \"../com/Game\";\nimport { Vector } from \"../com/Vector\";\n\nexport default class Drawer {\n    canvas: HTMLCanvasElement;\n\n    constructor(canvas: HTMLCanvasElement) {\n        this.canvas = canvas;\n    }\n\n    displayMessage(message: string) {\n        const ctx = this.canvas.getContext('2d');\n        if (ctx) {\n            ctx.fillStyle = 'black';\n            ctx.font = '48px serif';\n            ctx.fillText(message, 10, 50);\n        }\n    }\n\n    draw(game: Game) {\n        const ctx = this.canvas.getContext('2d');\n        if (ctx) {\n            ctx.clearRect(0, 0, GAME_LIMITS.x, GAME_LIMITS.y);\n            this.drawBG(ctx);\n            this.drawPlayer(game, ctx);\n            this.drawEnemies(game, ctx);\n            this.drawAlliesProjectiles(game, ctx);\n            this.drawEnemyProjectiles(game, ctx);\n            this.drawLifes(game, ctx);\n        }\n    }\n\n    drawBG(ctx: CanvasRenderingContext2D) {\n        ctx.fillStyle = 'rgba(200,200,200,.8)';\n        ctx.fillRect(0, 0, GAME_LIMITS.x, GAME_LIMITS.y);\n    }\n\n    drawPlayer(game: Game, ctx: CanvasRenderingContext2D) {\n        const {position, speed} = game.player;\n        ctx.strokeStyle = 'red';\n        ctx.fillStyle = game.player.is_invincible ? 'red' : 'orange';\n        ctx.fillRect(\n            position.x - PLAYER_HALF_SIZE,\n            position.y - PLAYER_HALF_SIZE,\n            PLAYER_SIZE,\n            PLAYER_SIZE);\n\n        // ctx.beginPath();\n        // ctx.moveTo(position.x,position.y);\n        // const tmp = new Vector(position);\n        // tmp.add(speed);\n        // ctx.lineTo(tmp.x, tmp.y);\n        // ctx.stroke();\n    }\n\n    drawEnemies(game: Game, ctx: CanvasRenderingContext2D) {\n        ctx.strokeStyle = 'green';\n        for (const enemy of game.enemies) {\n            // TODO: refacto and externalise. This is dirty.\n            if (enemy instanceof Square) {\n                ctx.strokeRect(\n                    enemy.position.x - ENEMY_HALF_SIZE,\n                    enemy.position.y - ENEMY_HALF_SIZE,\n                    ENEMY_SIZE,\n                    ENEMY_SIZE\n                );\n            } else if (enemy instanceof Circle) {\n                ctx.beginPath();\n                ctx.arc(enemy.position.x, enemy.position.y, ENEMY_HALF_SIZE, 0, 2 * Math.PI, false);\n                ctx.stroke();\n            }\n        }\n\n    }\n\n    drawAlliesProjectiles(game: Game, ctx: CanvasRenderingContext2D) {\n        ctx.strokeStyle = 'brown';\n        for (const proj of game.allies_projectiles) {\n            ctx.beginPath();\n            ctx.moveTo(proj.position.x, proj.position.y);\n            const tmp = new Vector(proj.position);\n            tmp.add(proj.speed);\n            ctx.lineTo(tmp.x, tmp.y);\n            ctx.stroke();\n        }\n    }\n\n    drawEnemyProjectiles(game: Game, ctx: CanvasRenderingContext2D) {\n        ctx.strokeStyle = 'red';\n        for (const proj of game.enemies_projectiles) {\n            ctx.beginPath();\n            ctx.moveTo(proj.position.x, proj.position.y);\n            const tmp = new Vector(proj.position);\n            tmp.add(proj.speed);\n            ctx.lineTo(tmp.x, tmp.y);\n            ctx.stroke();\n        }\n    }\n\n    drawLifes(game: Game, ctx: CanvasRenderingContext2D) {\n        ctx.strokeStyle = 'black';\n        ctx.fillStyle = 'red';\n        for (let idxLives = 0; idxLives < PLAYER_LIFES; idxLives++) {\n            ctx.beginPath();\n            ctx.moveTo(idxLives*LIFE_DISPLAY_SIZE + 10, 10);\n            ctx.lineTo(idxLives*LIFE_DISPLAY_SIZE + 8,9);\n            ctx.lineTo(idxLives*LIFE_DISPLAY_SIZE + 5,4);\n            ctx.lineTo(idxLives*LIFE_DISPLAY_SIZE + 6,3);\n            ctx.lineTo(idxLives*LIFE_DISPLAY_SIZE + 9,3);\n            ctx.lineTo(idxLives*LIFE_DISPLAY_SIZE + 10,5);\n            ctx.lineTo(idxLives*LIFE_DISPLAY_SIZE + 11,3);\n            ctx.lineTo(idxLives*LIFE_DISPLAY_SIZE + 14,3);\n            ctx.lineTo(idxLives*LIFE_DISPLAY_SIZE + 15,4);\n            ctx.lineTo(idxLives*LIFE_DISPLAY_SIZE + 12,9);\n            ctx.closePath();\n            if (game.player.lives > idxLives) {\n                ctx.fill();\n            } else {\n                ctx.stroke();\n            }\n        }\n    }\n\n}","import { GAME_LIMITS, SPECIAL_INPUTS_LATENCY } from \"./com/Constants\";\nimport Game from \"./com/Game\";\nimport Drawer from \"./draw/Drawer\";\nimport {getCurrentInput, PlayerInputs} from './com/PlayerInput';\n\nexport default class Application {\n    pause: boolean = true;\n    game: Game;\n    drawer: Drawer;\n    lastPauseTimeStamp: number = 0;\n    lastResetTimeStamp: number = 0;\n\n    tmpTimeStamp: number = 0;\n    timeSpentInPause: number = 0;\n    realGameTime: number = 0;\n\n    displayedMessageForPause: string = \"Waiting for gamePad...\";\n\n    constructor(canvasID: string) {\n        const canvas = document.getElementById(canvasID) as HTMLCanvasElement;\n        if (!canvas) {\n            throw new Error(\"Cant find canvas with id \"+canvasID);\n        } else {\n            canvas.style.width = GAME_LIMITS.x+'px';\n            canvas.style.height = GAME_LIMITS.y+'px';\n            canvas.setAttribute('width', GAME_LIMITS.x.toString());\n            canvas.setAttribute('height', GAME_LIMITS.y.toString());\n\n            this.game = new Game();\n            this.drawer = new Drawer(canvas);\n        }\n\n        // input gamepad events\n        window.addEventListener(\"gamepadconnected\", (e) => {            \n            this.pause = false;\n            this.displayedMessageForPause = \"Pause !\";\n        });\n    }\n\n    checkSpecialInputs(inputs: PlayerInputs, timestamp: number = 0) {\n        if (inputs.buttons.L1 && inputs.buttons.R1) {\n            if (timestamp - this.lastResetTimeStamp > SPECIAL_INPUTS_LATENCY) {\n                this.game.reset();\n                this.lastResetTimeStamp = timestamp;\n            }\n        }\n\n        if (inputs.buttons.Pause) {\n            if (timestamp - this.lastPauseTimeStamp > SPECIAL_INPUTS_LATENCY) {\n                this.pause = !this.pause;\n                this.lastPauseTimeStamp = timestamp;\n            }\n        }\n    }\n\n    correctTimeStamps(timestamp:number = 0) {\n        const diff = timestamp - this.tmpTimeStamp;\n        this.tmpTimeStamp = timestamp;\n        if (this.pause) {\n            this.timeSpentInPause += diff;\n        } else {\n            this.realGameTime += diff;\n        }\n    }\n    \n    loop = (timestamp?: number) => {\n        this.correctTimeStamps(timestamp);\n\n        const inputs = getCurrentInput();\n\n        this.checkSpecialInputs(inputs, timestamp);\n\n        if (!this.pause) {\n            this.game.schedule(this.realGameTime, inputs);\n        }\n\n        this.drawer.draw(this.game);\n\n        if (this.pause) {\n            this.drawer.displayMessage(this.displayedMessageForPause);\n        }\n\n        requestAnimationFrame(this.loop);\n    }\n\n}","import Application from \"./Application\";\n\nfunction init () {\n    const app = new Application('main');\n    app.loop();\n}\n\ndocument.addEventListener('DOMContentLoaded', init );"],"names":["$f9a18ee3f7d45d0ad2fcdae4157db9d3$export$Vector","constructor","v","this","x","y","max","Math","random","add","minus","multByScalar","scalar","lenght","sqrt","normalize","tmpL","distanceTo","other","$f3620c22e110fbf4898f00310db65a10$export$GAME_LIMITS","$f3620c22e110fbf4898f00310db65a10$export$PLAYER_HALF_SIZE","$f3620c22e110fbf4898f00310db65a10$export$PLAYER_SIZE","$f3620c22e110fbf4898f00310db65a10$export$ENEMY_HALF_SIZE","$f3620c22e110fbf4898f00310db65a10$export$ENEMY_SIZE","$f3620c22e110fbf4898f00310db65a10$export$LIFE_DISPLAY_SIZE","$d213cfefffcbef50b09fafe077dfc2e3$export$Entity","alive","pos","speed","size","position","intersect","threshold","distance","die","$793db38c4fea658d9db77ab0ab71904e$export$default","spawnTimestamp","super","deathTimestamp","move","isAlive","timestamp","$90eee1ae0574a202f17e5205809835fd$export$default","lives","fire_delay","last_fire_timestamp","input","target","tmpPos","decreaseLife","val","fire","targetPos","$73b3855620c4067ea4becc08330dae31$export$default","tmpSpeed","$b720f7fa0b24c83f4037ed87f1d03527$export$default","$8020c272b56f4800ea1c6e41707815bf$var$getLastUsedGamePad","pads","Array","from","navigator","getGamepads","sort","a","b","$8020c272b56f4800ea1c6e41707815bf$export$gamePadRumble","force","duration","gamePad","vibrationActuator","playEffect","startDelay","weakMagnitude","strongMagnitude","$0d9bdd3cea7474ee2bc11b071e461e2d$export$default","is_invincible","invincible_until_timestamp","positionInput","inputs","fireInput","touchTimestamp","checkInvincibility","$e592ad1078d5a01212c7f167146ecb31$export$default","enemies","nextSpawnTimestamp","allies_projectiles","enemies_projectiles","player","reset","schedule","push","proj","enemy","filter","e","length","spawnRandomEnemy","rdmPos","getRandomVector","$40b0018c3c22015aa4336c2618236c9c$export$default","canvas","displayMessage","message","ctx","getContext","fillStyle","font","fillText","draw","game","clearRect","drawBG","drawPlayer","drawEnemies","drawAlliesProjectiles","drawEnemyProjectiles","drawLifes","fillRect","strokeStyle","strokeRect","beginPath","arc","PI","stroke","moveTo","tmp","lineTo","idxLives","closePath","fill","$e779a980621a870b446c1bb8a47cb516$export$default","pause","lastPauseTimeStamp","lastResetTimeStamp","tmpTimeStamp","timeSpentInPause","realGameTime","displayedMessageForPause","canvasID","document","getElementById","Error","style","width","height","setAttribute","toString","drawer","window","addEventListener","checkSpecialInputs","buttons","L1","R1","Pause","correctTimeStamps","diff","loop","pressed","axes","requestAnimationFrame","app"],"version":3,"file":"index.a22e20bf.js.map"}